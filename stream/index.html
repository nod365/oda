<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8" />
  <title>–í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –†–∞–¥–∏–æ –í–µ–¥—É—â–∏–π</title>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background: #111;
      color: #0f0;
      padding: 20px;
    }

    h1 {
      color: #0ff;
    }

    .track {
      margin-bottom: 10px;
    }

    .playing {
      color: yellow;
    }
  </style>
</head>

<body>
  <h2>–ó–∞–≥—Ä—É–∑–∏—Ç–µ ZIP —Å –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º</h2>
  <input type="file" id="zipInput" accept=".zip" />
  <div id="status">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏...</div>
  <h1>üéôÔ∏è </h1>
  <div id="now-playing"></div>
  <button id="skipButton">‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å</button>
  <h2>–û—á–µ—Ä–µ–¥—å</h2>
  <div id="queue"></div>

  <script>
    const blobsCache = {};
    window.pathToOriginalFileName = window.pathToOriginalFileName || {};

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    const createNormalizedAudio = () => {
      const audio = new Audio();
      const source = audioContext.createMediaElementSource(audio);
      const compressor = audioContext.createDynamicsCompressor();

      compressor.threshold.setValueAtTime(-24, audioContext.currentTime);
      compressor.knee.setValueAtTime(30, audioContext.currentTime);
      compressor.ratio.setValueAtTime(12, audioContext.currentTime);
      compressor.attack.setValueAtTime(0.003, audioContext.currentTime);
      compressor.release.setValueAtTime(0.25, audioContext.currentTime);

      source.connect(compressor);
      compressor.connect(audioContext.destination);

      return audio;
    };

    const musicAudioA = createNormalizedAudio();
    const musicAudioB = createNormalizedAudio();
    let musicToggle = true;

    const voiceAudio = createNormalizedAudio();
    const miscAudio = createNormalizedAudio();

    async function getBlobUrl(path) {
      if (blobsCache[path]) return blobsCache[path];

      const file = window.loadedZip.file(path);
      if (!file) throw new Error(`File ${path} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ ZIP`);

      const blob = await file.async("blob");
      const blobUrl = URL.createObjectURL(blob);

      blobsCache[path] = blobUrl;
      window.pathToOriginalFileName[blobUrl] = path.split('/').pop();

      return blobUrl;
    }

    let queue = [];
    let playIndex = 0;
    let currentHour = new Date().getHours();

    let SONGS = {};
    let JINGLES = [];
    let ADS = [];
    let DTMF = {};
    let RANDOM = [];

    let shuffledAds = [];
    let shuffledJingles = [];
    let adIndex = 0;
    let jingleIndex = 0;
    let originalSongs = [];
    let songsSinceLastJingle = 0;

    let adEvenIndex = 0;

    const QUEUE_AHEAD = 10;
    const hourSounds = {};

    const shuffle = arr => arr.sort(() => Math.random() - 0.5);
    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
    const extractFileName = path => window.pathToOriginalFileName[path] || path.split('/').pop() || '';

    function initOriginalSongs() {
      originalSongs = shuffle(Object.entries(SONGS));
    }

    function getNextAd() {
      if (shuffledAds.length === 0) shuffledAds = shuffle(ADS.slice());
      const index = adIndex++;
      return {
        src: shuffledAds[index % shuffledAds.length],
        endType: index % 2 === 0 ? 'even' : 'odd'
      };
    }

    function getNextJingle() {
      if (shuffledJingles.length === 0) shuffledJingles = shuffle(JINGLES.slice());
      return shuffledJingles[jingleIndex++ % shuffledJingles.length];
    }

    async function addTracksToQueue(count) {
      if (originalSongs.length === 0) initOriginalSongs();

      for (let i = 0; i < count; i++) {
        if (originalSongs.length === 0) initOriginalSongs();

        let found = false;
        let title, data;

        while (originalSongs.length > 0 && !found) {
          [title, data] = originalSongs.shift();
          if (!queue.slice(playIndex).some(item => item.title === title && item.type === 'song')) {
            found = true;
          }
        }

        if (!found) continue;

        const songSrc = await getBlobUrl(`songs/${data.link}`);

        let comments = [];
        const commentKeys = Object.keys(data.comments || {});
        if (commentKeys.length > 0) {
          comments = await Promise.all(
            commentKeys.map(async (k) => {
              const src = await getBlobUrl(`songs/${data.comments[k]}`);
              return { name: k, src, fileName: extractFileName(src) };
            })
          );
        }

        queue.push({
          type: 'song',
          title,
          songSrc,
          fileName: extractFileName(songSrc),
          comments
        });

        songsSinceLastJingle++;
        if (songsSinceLastJingle >= 1 && JINGLES.length) {
          const jinglePath = `j/${getNextJingle()}`;
          const jingleSrc = await getBlobUrl(jinglePath);
          queue.push({ type: 'jingle', title: 'üéµ –î–∂–∏–Ω–≥–ª', songSrc: jingleSrc, fileName: extractFileName(jingleSrc) });
          songsSinceLastJingle = 0;
        }

        const songsCount = queue.filter(item => item.type === 'song').length;
        if (songsCount > 0 && songsCount % 4 === 0 && ADS.length) {
          const adObj = getNextAd();
          const adSrc = await getBlobUrl(`ads/${adObj.src}`);
          queue.push({
            type: 'ad',
            title: 'üì¢ –†–µ–∫–ª–∞–º–∞',
            songSrc: adSrc,
            fileName: extractFileName(adSrc),
            adEndType: adObj.endType
          });
        }
      }
    }

    const updateDisplay = () => {
      const nowDiv = document.getElementById('now-playing');
      const queueDiv = document.getElementById('queue');
      const current = queue[playIndex] || {};
      nowDiv.innerHTML = `<div class="playing">üéß –°–µ–π—á–∞—Å: ${current?.title || '---'} (${current?.fileName || ''})</div>`;
      queueDiv.innerHTML = queue.slice(playIndex + 1, playIndex + 10).map((item, i) => {
        let icon = '';
        if (item.type === 'ad') icon = 'üì¢';
        else if (item.type === 'jingle') icon = 'üéµ';
        else if (item.type === 'hour-signal') icon = 'üïí';
        return `<div class="track">${i + 1}) ${item.title} ${icon} (${item.fileName || ''})</div>`;
      }).join('');
    };

    let hourSignalPending = false;

    const checkAndQueueHourSound = () => {
      const hour = new Date().getHours();
      if (hour !== currentHour && hourSounds[hour]) {
        currentHour = hour;
        hourSignalPending = true;
      }
    };

    const playAudio = (src) => {
      return new Promise(resolve => {
        miscAudio.pause();
        miscAudio.src = src;
        miscAudio.volume = 1;
        miscAudio.onended = resolve;
        miscAudio.play();
      });
    };

    async function playNext() {
      if (queue.length - playIndex < QUEUE_AHEAD) {
        await addTracksToQueue(QUEUE_AHEAD - (queue.length - playIndex));
      }

      updateDisplay();
      if (playIndex >= queue.length) return;

      if (hourSignalPending) {
        const hourSrc = await getBlobUrl(`h/${currentHour}.mp3`);
        queue.splice(playIndex, 0, {
          type: 'hour-signal',
          title: `üïí –°–∏–≥–Ω–∞–ª ${currentHour}:00`,
          songSrc: hourSrc,
          fileName: `h (${currentHour}).mp3`
        });
        hourSignalPending = false;
      }

      const item = queue[playIndex];
      playIndex++;

      if (item.type === 'song') {
        const songData = SONGS[item.title];
        const together = songData.together === 1;
        const hasComment = item.comments.length > 0;

        const currentMusic = musicToggle ? musicAudioA : musicAudioB;
        const nextMusic = !musicToggle ? musicAudioA : musicAudioB;
        musicToggle = !musicToggle;

        currentMusic.pause();
        currentMusic.src = item.songSrc;
        currentMusic.volume = 1;

        if (together && hasComment) {
          currentMusic.play();
          voiceAudio.src = item.comments[Math.floor(Math.random() * item.comments.length)].src;
          await delay(500);
          for (let v = 1; v >= 0.1; v -= 0.05) {
            currentMusic.volume = v;
            await delay(30);
          }
          voiceAudio.play();
          await new Promise(resolve => voiceAudio.onended = resolve);
          for (let v = 0.1; v <= 1; v += 0.05) {
            currentMusic.volume = v;
            await delay(30);
          }
          await new Promise(resolve => currentMusic.onended = resolve);
        } else {
          if (hasComment) {
            voiceAudio.src = item.comments[Math.floor(Math.random() * item.comments.length)].src;
            voiceAudio.play();
            await new Promise(resolve => voiceAudio.onended = resolve);
          }
          currentMusic.play();
          currentMusic.onended = () => playNext();

          // –ö—Ä–æ—Å—Å—Ñ–µ–π–¥: –∑–∞ 3 —Å–µ–∫—É–Ω–¥—ã –¥–æ –∫–æ–Ω—Ü–∞ –Ω–∞—á–Ω–µ–º —Å–ª–µ–¥—É—é—â–∏–π
          currentMusic.onloadedmetadata = () => {
            const duration = currentMusic.duration;
            if (!isNaN(duration)) {
              setTimeout(async () => {
                if (queue[playIndex] && queue[playIndex].type === 'song') {
                  const nextSrc = queue[playIndex].songSrc;
                  nextMusic.src = nextSrc;
                  nextMusic.volume = 0;
                  nextMusic.play();
                  for (let v = 0; v <= 1; v += 0.05) {
                    nextMusic.volume = v;
                    currentMusic.volume = 1 - v;
                    await delay(100);
                  }
                }
              }, (duration - 3) * 1000);
            }
          };
          return;
        }

      } else if (item.type === 'ad') {
        voiceAudio.src = DTMF.adStart ? await getBlobUrl(DTMF.adStart) : null;
        if (voiceAudio.src) await playAudio(voiceAudio.src);
        await playAudio(item.songSrc);

        if (item.adEndType === 'even') {
          const evenEndingKey = adEvenIndex % 2 === 0 ? 'adEndEven1' : 'adEndEven2';
          adEvenIndex++;
          await playAudio(await getBlobUrl(DTMF[evenEndingKey]));
        } else {
          await playAudio(await getBlobUrl(DTMF.adEndOdd));
        }

      } else if (item.type === 'jingle') {
        await playAudio(item.songSrc);
      } else if (item.type === 'hour-signal') {
        await playAudio(item.songSrc);
        await playAudio(await getBlobUrl(DTMF.newHour));
      }

      checkAndQueueHourSound();
      await playNext();
    }

    document.getElementById('zipInput').addEventListener('change', async (event) => {
      await audioContext.resume(); // –Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –±—Ä–∞—É–∑–µ—Ä —Ç—Ä–µ–±—É–µ—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ

      const file = event.target.files[0];
      if (!file) return;

      document.getElementById('status').textContent = "üì¶ –†–∞—Å–ø–∞–∫–æ–≤–∫–∞ ZIP...";
      const zip = await JSZip.loadAsync(file);

      window.loadedZip = zip;

      const contentRaw = await zip.file("content.js").async("string");
      const wrapperFn = new Function("global", contentRaw);
      wrapperFn(window);

      SONGS = window.SONGS;
      JINGLES = window.JINGLES || [];
      ADS = window.ADS || [];
      DTMF = window.DTMF || {};
      RANDOM = window.RANDOM || [];

      for (let h = 0; h < 24; h++) {
        const key = `h/${h}.mp3`;
        if (window.loadedZip.file(key)) {
          hourSounds[h] = await getBlobUrl(key);
        }
      }

      document.getElementById('status').textContent = "‚úÖ ZIP –∑–∞–≥—Ä—É–∂–µ–Ω. –ó–∞–ø—É—Å–∫ —ç—Ñ–∏—Ä–∞...";
      initOriginalSongs();
      await addTracksToQueue(QUEUE_AHEAD);

      document.getElementById('skipButton').addEventListener('click', async () => {
        musicAudioA.pause(); musicAudioA.currentTime = 0;
        musicAudioB.pause(); musicAudioB.currentTime = 0;
        voiceAudio.pause(); voiceAudio.currentTime = 0;
        miscAudio.pause(); miscAudio.currentTime = 0;

        await playNext();
      });

      setInterval(checkAndQueueHourSound, 10 * 1000);
      await playNext();
    });
  </script>
</body>

</html>
