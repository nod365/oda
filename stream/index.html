<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8" />
  <title>–í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –†–∞–¥–∏–æ –í–µ–¥—É—â–∏–π</title>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background: #111;
      color: #0f0;
      padding: 20px;
    }

    h1 {
      color: #0ff;
    }

    .track {
      margin-bottom: 10px;
    }

    .playing {
      color: yellow;
    }
  </style>
</head>

<body>
  <h2>–ó–∞–≥—Ä—É–∑–∏—Ç–µ ZIP —Å –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º</h2>
  <input type="file" id="zipInput" accept=".zip" />
  <div id="status">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏...</div>
  <h1>üéôÔ∏è </h1>
  <div id="now-playing"></div>
  <button id="skipButton">‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å</button>
  <h2>–û—á–µ—Ä–µ–¥—å</h2>
  <div id="queue"></div>

  <script>
    const musicAudio = new Audio();
    const voiceAudio = new Audio();
    const miscAudio = new Audio();

    voiceAudio.volume = 1;
    musicAudio.volume = 1;

    let queue = [];
    let playIndex = 0;
    let currentHour = new Date().getHours();

    let SONGS = {};
    let JINGLES = [];
    let ADS = [];
    let DTMF = {};

    let shuffledAds = [];
    let shuffledJingles = [];
    let adIndex = 0;
    let jingleIndex = 0;
    let originalSongs = [];
    let songsSinceLastJingle = 0;

    const QUEUE_AHEAD = 10;
    const hourSounds = {};
    const pathToOriginalFileName = {};

    const shuffle = arr => arr.sort(() => Math.random() - 0.5);
    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
    const extractFileName = path => pathToOriginalFileName[path] || path.split('/').pop() || '';

    function initOriginalSongs() {
      originalSongs = shuffle(Object.entries(SONGS));
    }

    function getNextAd() {
      if (shuffledAds.length === 0) shuffledAds = shuffle(ADS.slice());
      const index = adIndex++;
      return {
        src: shuffledAds[index % shuffledAds.length],
        endType: index % 2 === 0 ? 'even' : 'odd'
      };
    }

    function getNextJingle() {
      if (shuffledJingles.length === 0) shuffledJingles = shuffle(JINGLES.slice());
      return shuffledJingles[jingleIndex++ % shuffledJingles.length];
    }

    function addTracksToQueue(count) {
      if (originalSongs.length === 0) initOriginalSongs();

      for (let i = 0; i < count; i++) {
        if (originalSongs.length === 0) initOriginalSongs();

        let found = false;
        let title, data;

        while (originalSongs.length > 0 && !found) {
          [title, data] = originalSongs.shift();
          if (!queue.slice(playIndex).some(item => item.title === title && item.type === 'song')) {
            found = true;
          }
        }

        if (!found) continue;

        queue.push({
          type: 'song',
          title,
          songSrc: data.link,
          fileName: extractFileName(data.link),
          comments: Object.entries(data.comments || {}).map(([k, v]) => ({
            name: k,
            src: v,
            fileName: extractFileName(v)
          }))
        });

        songsSinceLastJingle++;
        if (songsSinceLastJingle >= 2 && JINGLES.length) {
          const jingle = getNextJingle();
          queue.push({ type: 'jingle', title: 'üéµ –î–∂–∏–Ω–≥–ª', songSrc: jingle, fileName: extractFileName(jingle) });
          songsSinceLastJingle = 0;
        }

        const songsCount = queue.filter(item => item.type === 'song').length;
        if (songsCount > 0 && songsCount % 4 === 0 && ADS.length) {
          const ad = getNextAd();
          queue.push({
            type: 'ad',
            title: 'üì¢ –†–µ–∫–ª–∞–º–∞',
            songSrc: ad.src,
            fileName: extractFileName(ad.src),
            adEndType: ad.endType // üëà –¥–æ–±–∞–≤–ª—è–µ–º
          });
        }
      }
    }

    const updateDisplay = () => {
      const nowDiv = document.getElementById('now-playing');
      const queueDiv = document.getElementById('queue');
      const current = queue[playIndex] || {};
      nowDiv.innerHTML = `<div class="playing">üéß –°–µ–π—á–∞—Å: ${current?.title || '---'} (${current?.fileName || ''})</div>`;
      queueDiv.innerHTML = queue.slice(playIndex + 1, playIndex + 10).map((item, i) => {
        let icon = '';
        if (item.type === 'ad') icon = 'üì¢';
        else if (item.type === 'jingle') icon = 'üéµ';
        else if (item.type === 'hour-signal') icon = 'üïí';
        return `<div class="track">${i + 1}) ${item.title} ${icon} (${item.fileName || ''})</div>`;
      }).join('');
    };

    let hourSignalPending = false;

    const checkAndQueueHourSound = () => {
      const hour = new Date().getHours();
      if (hour !== currentHour && hourSounds[hour]) {
        currentHour = hour;
        hourSignalPending = true;
      }
    };

    const playAudio = (src) => {
      return new Promise(resolve => {
        miscAudio.pause();
        miscAudio.src = src;
        miscAudio.volume = 1;
        miscAudio.onended = resolve;
        miscAudio.play();
      });
    };

    const playNext = async () => {
      if (queue.length - playIndex < QUEUE_AHEAD) {
        addTracksToQueue(QUEUE_AHEAD - (queue.length - playIndex));
      }

      updateDisplay();
      if (playIndex >= queue.length) return;

      if (hourSignalPending) {
        queue.splice(playIndex, 0, {
          type: 'hour-signal',
          title: `üïí –°–∏–≥–Ω–∞–ª ${currentHour}:00`,
          songSrc: hourSounds[currentHour],
          fileName: `h (${currentHour}).mp3`
        });
        hourSignalPending = false;
      }

      const item = queue[playIndex];
      playIndex++;

      if (item.type === 'song') {
        const songData = SONGS[item.title];
        const together = songData.together === 1;
        const hasComment = item.comments.length > 0;

        let comment;
        if (hasComment) {
          comment = item.comments[Math.floor(Math.random() * item.comments.length)];
          voiceAudio.src = comment.src;
        }

        if (together) {
          musicAudio.src = item.songSrc;
          musicAudio.play();
          if (hasComment) {
            await delay(500);
            for (let v = 1; v >= 0.3; v -= 0.05) {
              musicAudio.volume = v;
              await delay(30);
            }
            voiceAudio.play();
            await new Promise(resolve => voiceAudio.onended = resolve);
            for (let v = 0.3; v <= 1; v += 0.05) {
              musicAudio.volume = v;
              await delay(30);
            }
          }
          await new Promise(resolve => musicAudio.onended = resolve);
        } else {
          if (hasComment) {
            voiceAudio.play();
            await new Promise(resolve => voiceAudio.onended = resolve);
          }
          musicAudio.src = item.songSrc;
          musicAudio.play();
          await new Promise(resolve => musicAudio.onended = resolve);
        }
      } else if (item.type === 'ad') {
        await playAudio(DTMF.adStart);
        await playAudio(item.songSrc);
        await playAudio(item.adEndType === 'even' ? DTMF.adEndEven : DTMF.adEndOdd); // üëà —Ç–µ–ø–µ—Ä—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ
      } else if (item.type === 'jingle') {
        await playAudio(item.songSrc);
      } else if (item.type === 'hour-signal') {
        await playAudio(item.songSrc);
        await playAudio(DTMF.newHour);
      }

      checkAndQueueHourSound();
      playNext();
    };

    document.getElementById('zipInput').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;

      document.getElementById('status').textContent = "üì¶ –†–∞—Å–ø–∞–∫–æ–≤–∫–∞ ZIP...";
      const zip = await JSZip.loadAsync(file);
      const blobs = {};

      for (const path of Object.keys(zip.files)) {
        const file = zip.files[path];
        if (!file.dir) {
          const blob = await file.async('blob');
          const blobUrl = URL.createObjectURL(blob);
          blobs[path] = blobUrl;
          pathToOriginalFileName[blobUrl] = path.split('/').pop();
        }
      }

      const contentRaw = await zip.file("content.js").async("string");
      const wrapperFn = new Function("global", contentRaw);
      wrapperFn(window);

      SONGS = window.SONGS;
      JINGLES = window.JINGLES.map(name => blobs[`j/${name}`]);
      ADS = window.ADS.map(name => blobs[`ads/${name}`]);
      DTMF = Object.fromEntries(Object.entries(window.DTMF).map(([k, v]) => [k, blobs[v]]));
      RANDOM = (window.RANDOM || []).map(name => blobs[`random/${name}`]);

      for (const [title, songData] of Object.entries(SONGS)) {
        songData.link = blobs[`songs/${songData.link}`];

        // –ó–∞–º–µ–Ω–∏–º –ø—É—Å—Ç—ã–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ —Å–ª—É—á–∞–π–Ω—ã–º –∏–∑ RANDOM
        const commentKeys = Object.keys(songData.comments || {});
        if (commentKeys.length === 0 && RANDOM.length > 0) {
          const randomIndex = Math.floor(Math.random() * RANDOM.length);
          songData.comments = {
            —Å–ª—É—á–∞–π–Ω—ã–π: RANDOM[randomIndex]
          };
        } else {
          for (const key in songData.comments) {
            songData.comments[key] = blobs[`songs/${songData.comments[key]}`];
          }
        }
      }

      for (let h = 0; h < 24; h++) {
        const key = `h/${h}.mp3`;
        if (blobs[key]) hourSounds[h] = blobs[key];
      }

      document.getElementById('status').textContent = "‚úÖ ZIP –∑–∞–≥—Ä—É–∂–µ–Ω. –ó–∞–ø—É—Å–∫ —ç—Ñ–∏—Ä–∞...";
      initOriginalSongs();
      addTracksToQueue(QUEUE_AHEAD);

      document.getElementById('skipButton').addEventListener('click', () => {
        // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ–±–∞ –ø–ª–µ–µ—Ä–∞
        musicAudio.pause();
        musicAudio.currentTime = 0;
        voiceAudio.pause();
        voiceAudio.currentTime = 0;
        miscAudio.pause();
        miscAudio.currentTime = 0;
        
        // –ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Ç—Ä–µ–∫—É
        playNext();
      });

      setInterval(checkAndQueueHourSound, 10 * 1000);
      playNext();
    });
  </script>
</body>

</html>
