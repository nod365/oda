<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8" />
  <title>Radio Player</title>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background: #111;
      color: #0f0;
      padding: 20px;
    }

    h1 {
      color: #0ff;
    }

    .track {
      margin-bottom: 10px;
    }

    .playing {
      color: yellow;
    }
  </style>
</head>

<body>
  <h2>–ó–∞–≥—Ä—É–∑–∏—Ç–µ ZIP —Å –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º</h2>
  <input type="file" id="zipInput" accept=".zip" />
  <div id="status">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏...</div>
  <h1>üéôÔ∏è </h1>
  <div id="now-playing"></div>
  <button id="skipButton">‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å</button>
  <h2>–û—á–µ—Ä–µ–¥—å</h2>
  <div id="queue"></div>

  <script>
let song = "NOTHING IS PLAYING"; // –≥–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è
let lastSong = song;         // –ø–æ—Å–ª–µ–¥–Ω—è—è –≤–µ—Ä—Å–∏—è –ø–µ—Å–Ω–∏
let songPos = 0;             // –ø–æ–∑–∏—Ü–∏—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ –ø–µ—Å–Ω–∏
const artistWidth = 15;      // —à–∏—Ä–∏–Ω–∞ –æ–∫–Ω–∞ artist

const stationText = "HYPERPOP PLAZA 104.0 FM - REKLAMA +74959250444";
let stationPos = 0;          // –ø–æ–∑–∏—Ü–∏—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ title
const titleWidth = 15;       // —à–∏—Ä–∏–Ω–∞ –æ–∫–Ω–∞ title

const step = 3;              // —à–∞–≥ –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ (–∫–∞–∫ —Ä–∞–Ω—å—à–µ)

function startRadioMetadata() {

    if (window.radioUpdater) {
        clearInterval(window.radioUpdater);
    }

    function scrollText(source, pos, width) {
        if (source.length <= width) {
            return { out: source, nextPos: 0 };
        }

        const extended = source + "     ";

        let showing = extended.substr(pos, width);
        if (showing.length < width) {
            showing += extended.substr(0, width - showing.length);
        }

        return {
            out: showing,
            nextPos: (pos + step) % extended.length
        };
    }

    function update() {
        if (!('mediaSession' in navigator)) return;

        const date = new Date();
        const time =
            String(date.getHours()).padStart(2, '0') + ':' +
            String(date.getMinutes()).padStart(2, '0')+ ' SERPUKHOV';

        if (song !== lastSong) {
            lastSong = song;
            songPos = 0;
        }

        const t = scrollText(stationText, stationPos, titleWidth);
        stationPos = t.nextPos;

        const a = scrollText(song, songPos, artistWidth);
        songPos = a.nextPos;

        navigator.mediaSession.metadata = new MediaMetadata({
            title: a.out,
            artist: t.out,
            album: time
        });
    }

    window.radioUpdater = setInterval(update, 1000);
    update();
    console.log('–ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∑–∞–ø—É—â–µ–Ω—ã');
}

function stopRadioMetadata() {
    if (window.radioUpdater) {
        clearInterval(window.radioUpdater);
        window.radioUpdater = null;
    }
    if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = null;
    }
    console.log('–ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã');
}

startRadioMetadata();


function normalizeFilename(name) {

    // 1. —É–±–∏—Ä–∞–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –¥–æ –ø–µ—Ä–≤–æ–π —Ç–æ—á–∫–∏
    const dotIndex = name.indexOf(".");
    if (dotIndex !== -1) {
        name = name.slice(dotIndex + 1);
    }

    // 2. —É–±–∏—Ä–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ .mp3
    name = name.replace(/\.mp3$/i, "");
    
    // 2,5. —É–±–∏—Ä–∞–µ–º (Unknown) –≤–µ–∑–¥–µ 
    name = name.replaceAll("(Unknown)", "");

    // 3. –∑–∞–º–µ–Ω—è–µ–º _ –Ω–∞ –ø—Ä–æ–±–µ–ª
    name = name.replace(/_/g, " ");

    // 4. —Ç—Ä–∞–Ω—Å–ª–∏—Ç
    const map = {
        –ê:"A", –ë:"B", –í:"V", –ì:"G", –î:"D", –ï:"E", –Å:"E", –ñ:"ZH", –ó:"Z",
        –ò:"I", –ô:"Y", –ö:"K", –õ:"L", –ú:"M", –ù:"N", –û:"O", –ü:"P", –†:"R",
        –°:"S", –¢:"T", –£:"U", –§:"F", –•:"KH", –¶:"TS", –ß:"CH", –®:"SH",
        –©:"SCH", –´:"Y", –≠:"E", –Æ:"YU", –Ø:"YA",

        –¨:"", –™:"",

        –∞:"A", –±:"B", –≤:"V", –≥:"G", –¥:"D", –µ:"E", —ë:"E", –∂:"ZH", –∑:"Z",
        –∏:"I", –π:"Y", –∫:"K", –ª:"L", –º:"M", –Ω:"N", –æ:"O", –ø:"P", —Ä:"R",
        —Å:"S", —Ç:"T", —É:"U", —Ñ:"F", —Ö:"KH", —Ü:"TS", —á:"CH", —à:"SH",
        —â:"SCH", —ã:"Y", —ç:"E", —é:"YU", —è:"YA",

        —å:"", —ä:""
    };

    name = name.split("").map(ch => map[ch] !== undefined ? map[ch] : ch).join("");

    // 5. –≤ –≤–µ—Ä—Ö–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä
    return name.toUpperCase();
}

    
    const blobsCache = {};
    // –£–±–∏—Ä–∞–µ–º –≤–æ–∑–º–æ–∂–Ω–æ–µ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–±—ä—è–≤–ª–µ–Ω–∏—è ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç
    window.pathToOriginalFileName = window.pathToOriginalFileName || {};

    async function getBlobUrl(path) {
      if (blobsCache[path]) return blobsCache[path];

      const file = window.loadedZip.file(path);
      if (!file) throw new Error(`File ${path} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ ZIP`);

      const blob = await file.async("blob");
      const blobUrl = URL.createObjectURL(blob);

      blobsCache[path] = blobUrl;
      window.pathToOriginalFileName[blobUrl] = path.split('/').pop();

      return blobUrl;
    }

    const musicAudio = new Audio();
    const voiceAudio = new Audio();
    const miscAudio = new Audio();

    voiceAudio.volume = 1;
    musicAudio.volume = 1;

    let queue = [];
    let playIndex = 0;
    let currentHour = new Date().getHours();

    let SONGS = {};
    let JINGLES = [];
    let ADS = [];
    let DTMF = {};
    let RANDOM = [];

    let shuffledAds = [];
    let shuffledJingles = [];
    let adIndex = 0;
    let jingleIndex = 0;
    let originalSongs = [];
    let songsSinceLastJingle = 0;

    let adEvenIndex = 0;

    const QUEUE_AHEAD = 10;
    const hourSounds = {};

    function shuffle(array) {
      let arr = array.slice(); // –∫–æ–ø–∏—Ä—É–µ–º, —á—Ç–æ–±—ã –Ω–µ –º—É—Ç–∏—Ä–æ–≤–∞—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª
      for (let i = arr.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
    const extractFileName = path => window.pathToOriginalFileName[path] || path.split('/').pop() || '';

    function initOriginalSongs() {
      originalSongs = shuffle(Object.entries(SONGS));
    }

    function getNextAd() {
      if (shuffledAds.length === 0) shuffledAds = shuffle(ADS.slice());
      const index = adIndex++;
      return {
        src: shuffledAds[index % shuffledAds.length],
        endType: index % 2 === 0 ? 'even' : 'odd'
      };
    }

    function getNextJingle() {
      if (shuffledJingles.length === 0) shuffledJingles = shuffle(JINGLES.slice());
      return shuffledJingles[jingleIndex++ % shuffledJingles.length];
    }

    async function addTracksToQueue(count) {
      if (originalSongs.length === 0) initOriginalSongs();

      for (let i = 0; i < count; i++) {
        if (originalSongs.length === 0) initOriginalSongs();

        let found = false;
        let title, data;

        while (originalSongs.length > 0 && !found) {
          [title, data] = originalSongs.shift();
          if (!queue.slice(playIndex).some(item => item.title === title && item.type === 'song')) {
            found = true;
          }
        }

        if (!found) continue;

        // –õ–µ–Ω–∏–≤–æ –ø–æ–¥–≥—Ä—É–∂–∞–µ–º –∞—É–¥–∏–æ –ø–µ—Å–Ω—é –∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏
        const songSrc = await getBlobUrl(`songs/${data.link}`);

        let comments = [];
        const commentKeys = Object.keys(data.comments || {});
        if (commentKeys.length === 0 && RANDOM.length > 0) {
          //const randomIndex = Math.floor(Math.random() * RANDOM.length);
          //const randomCommentSrc = await getBlobUrl(`random/${RANDOM[randomIndex]}`);
          //comments = [{ name: '—Å–ª—É—á–∞–π–Ω—ã–π', src: randomCommentSrc, fileName: extractFileName(randomCommentSrc) }];
          //console.log('–ü—É—Å—Ç–æ')
        } else {
          comments = await Promise.all(
            commentKeys.map(async (k) => {
              const src = await getBlobUrl(`songs/${data.comments[k]}`);
              return { name: k, src, fileName: extractFileName(src) };
            })
          );
        }

        queue.push({
          type: 'song',
          title: extractFileName(songSrc),
          songSrc,
          fileName: extractFileName(songSrc),
          comments
        });

        songsSinceLastJingle++;
        if (songsSinceLastJingle >= 1 && JINGLES.length) {
          const jinglePath = `j/${getNextJingle()}`;
          const jingleSrc = await getBlobUrl(jinglePath);
          queue.push({ type: 'jingle', title: 'Jingle', songSrc: jingleSrc, fileName: extractFileName(jingleSrc) });
          songsSinceLastJingle = 0;
        }

        const songsCount = queue.filter(item => item.type === 'song').length;
        if (songsCount > 0 && songsCount % 4 === 0 && ADS.length) {
          const adObj = getNextAd();
          const adSrc = await getBlobUrl(`ads/${adObj.src}`);
          queue.push({
            type: 'ad',
            title: '–†–µ–∫–ª–∞–º–∞',
            songSrc: adSrc,
            fileName: extractFileName(adSrc),
            adEndType: adObj.endType
          });
        }
      }
    }


    const updateDisplay = () => {
      const nowDiv = document.getElementById('now-playing');
      const queueDiv = document.getElementById('queue');
      const current = queue[playIndex] || {};
      nowDiv.innerHTML = `<div class="playing">üéß –°–µ–π—á–∞—Å: ${current?.title || '---'} (${current?.fileName || ''})</div>`;
      song = normalizeFilename(current?.title)
      queueDiv.innerHTML = queue.slice(playIndex + 1, playIndex + 10).map((item, i) => {
        let icon = '';
        if (item.type === 'ad') icon = 'üì¢';
        else if (item.type === 'jingle') icon = 'üéµ';
        else if (item.type === 'hour-signal') icon = 'üïí';
        return `<div class="track">${i + 1}) ${item.title} ${icon} (${item.fileName || ''})</div>`;
      }).join('');
    };

    let hourSignalPending = false;

    const checkAndQueueHourSound = () => {
      const hour = new Date().getHours();
      if (hour !== currentHour && hourSounds[hour]) {
        currentHour = hour;
        hourSignalPending = true;
      }
    };

    const playAudio = (src) => {
      return new Promise(resolve => {
        miscAudio.pause();
        miscAudio.src = src;
        miscAudio.volume = 1;
        miscAudio.onended = resolve;
        miscAudio.play();
      });
    };

    async function playNext() {
      if (queue.length - playIndex < QUEUE_AHEAD) {
        await addTracksToQueue(QUEUE_AHEAD - (queue.length - playIndex));
      }

      updateDisplay();
      if (playIndex >= queue.length) return;

      if (hourSignalPending) {
        const hourSrc = await getBlobUrl(`h/${currentHour}.mp3`);
        queue.splice(playIndex, 0, {
          type: 'hour-signal',
          title: `üïí –°–∏–≥–Ω–∞–ª ${currentHour}:00`,
          songSrc: hourSrc,
          fileName: `h (${currentHour}).mp3`
        });
        hourSignalPending = false;
      }

      const item = queue[playIndex];
      playIndex++;

      if (item.type === 'song') {
        const songData = SONGS[item.title];
        const together = songData.together === 1;
        const hasComment = item.comments.length > 0;

        if (together) {
          musicAudio.src = item.songSrc;
          musicAudio.play();
          if (hasComment) {
            voiceAudio.src = item.comments[Math.floor(Math.random() * item.comments.length)].src;
            await delay(500);
            for (let v = 1; v >= 0.1; v -= 0.05) {
              musicAudio.volume = v;
              await delay(30);
            }
            voiceAudio.play();
            await new Promise(resolve => voiceAudio.onended = resolve);
            for (let v = 0.1; v <= 1; v += 0.05) {
              musicAudio.volume = v;
              await delay(30);
            }
          }
          await new Promise(resolve => musicAudio.onended = resolve);
        } else {
          if (hasComment) {
            voiceAudio.src = item.comments[Math.floor(Math.random() * item.comments.length)].src;
            voiceAudio.play();
            await new Promise(resolve => voiceAudio.onended = resolve);
          }
          musicAudio.src = item.songSrc;
          musicAudio.play();
          await new Promise(resolve => musicAudio.onended = resolve);
        }
      } else if (item.type === 'ad') {
        voiceAudio.src = DTMF.adStart ? await getBlobUrl(DTMF.adStart) : null;
        if (voiceAudio.src) await playAudio(voiceAudio.src);
        await playAudio(item.songSrc);

        if (item.adEndType === 'even') {
          const evenEndingKey = adEvenIndex % 2 === 0 ? 'adEndEven1' : 'adEndEven2';
          adEvenIndex++;
          await playAudio(await getBlobUrl(DTMF[evenEndingKey]));
        } else {
          await playAudio(await getBlobUrl(DTMF.adEndOdd));
        }
      } else if (item.type === 'jingle') {
        await playAudio(item.songSrc);
      } else if (item.type === 'hour-signal') {
        await playAudio(item.songSrc);
        await playAudio(await getBlobUrl(DTMF.newHour));
      }

      checkAndQueueHourSound();
      await playNext();
    }


    document.getElementById('zipInput').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;

      document.getElementById('status').textContent = "üì¶ –†–∞—Å–ø–∞–∫–æ–≤–∫–∞ ZIP...";
      const zip = await JSZip.loadAsync(file);

      window.loadedZip = zip;

      const contentRaw = await zip.file("content.js").async("string");
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∞ —Å pathToOriginalFileName –≤ content.js
      // –ï—Å–ª–∏ content.js —Ç–∞–∫–∂–µ –æ–±—ä—è–≤–ª—è–µ—Ç pathToOriginalFileName, –Ω—É–∂–Ω–æ —É–±—Ä–∞—Ç—å const/let —Ç–∞–º –∏–ª–∏ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å
      const wrapperFn = new Function("global", contentRaw);
      wrapperFn(window);

      SONGS = window.SONGS;
      JINGLES = window.JINGLES || [];
      ADS = window.ADS || [];
      DTMF = window.DTMF || {};
      RANDOM = window.RANDOM || [];

      // –ó–∞–≥—Ä—É–∂–∞–µ–º —á–∞—Å–æ–≤—ã–µ –∑–≤—É–∫–∏ –≤ hourSounds (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ)
      for (let h = 0; h < 24; h++) {
        const key = `h/${h}.mp3`;
        if (window.loadedZip.file(key)) {
          hourSounds[h] = await getBlobUrl(key);
        }
      }

      document.getElementById('status').textContent = "‚úÖ ZIP –∑–∞–≥—Ä—É–∂–µ–Ω. –ó–∞–ø—É—Å–∫ —ç—Ñ–∏—Ä–∞...";
      initOriginalSongs();
      await addTracksToQueue(QUEUE_AHEAD);

      // –°–¥–µ–ª–∞–ª –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ async, —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ await playNext()
      document.getElementById('skipButton').addEventListener('click', async () => {
        musicAudio.pause();
        musicAudio.currentTime = 0;
        voiceAudio.pause();
        voiceAudio.currentTime = 0;
        miscAudio.pause();
        miscAudio.currentTime = 0;

        await playNext();
      });

      setInterval(checkAndQueueHourSound, 10 * 1000);
      await playNext();
    });
  </script>
</body>

</html>