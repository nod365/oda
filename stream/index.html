<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8" />
  <title>–í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –†–∞–¥–∏–æ –í–µ–¥—É—â–∏–π</title>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background: #111;
      color: #0f0;
      padding: 20px;
    }

    h1 {
      color: #0ff;
    }

    .track {
      margin-bottom: 10px;
    }

    .playing {
      color: yellow;
    }
  </style>
</head>

<body>
  <h2>–ó–∞–≥—Ä—É–∑–∏—Ç–µ ZIP —Å –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º</h2>
  <input type="file" id="zipInput" accept=".zip" />
  <div id="status">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏...</div>
  <h1>üéôÔ∏è </h1>
  <div id="now-playing"></div>
  <button id="skipButton">‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å</button>
  <h2>–û—á–µ—Ä–µ–¥—å</h2>
  <div id="queue"></div>

  <script>
    const blobsCache = {};
    // –£–±–∏—Ä–∞–µ–º –≤–æ–∑–º–æ–∂–Ω–æ–µ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–±—ä—è–≤–ª–µ–Ω–∏—è ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç
    window.pathToOriginalFileName = window.pathToOriginalFileName || {};

    async function getBlobUrl(path) {
      if (blobsCache[path]) return blobsCache[path];

      const file = window.loadedZip.file(path);
      if (!file) throw new Error(`File ${path} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ ZIP`);

      const blob = await file.async("blob");
      const blobUrl = URL.createObjectURL(blob);

      blobsCache[path] = blobUrl;
      window.pathToOriginalFileName[blobUrl] = path.split('/').pop();

      return blobUrl;
    }

    const musicAudio = new Audio();
    const voiceAudio = new Audio();
    const miscAudio = new Audio();

    voiceAudio.volume = 1;
    musicAudio.volume = 1;

    let queue = [];
    let playIndex = 0;
    let currentHour = new Date().getHours();

    let SONGS = {};
    let JINGLES = [];
    let ADS = [];
    let DTMF = {};
    let RANDOM = [];

    let shuffledAds = [];
    let shuffledJingles = [];
    let adIndex = 0;
    let jingleIndex = 0;
    let originalSongs = [];
    let songsSinceLastJingle = 0;

    let adEvenIndex = 0;

    const QUEUE_AHEAD = 10;
    const hourSounds = {};

    function shuffle(array) {
      let arr = array.slice(); // –∫–æ–ø–∏—Ä—É–µ–º, —á—Ç–æ–±—ã –Ω–µ –º—É—Ç–∏—Ä–æ–≤–∞—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª
      for (let i = arr.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
    const extractFileName = path => window.pathToOriginalFileName[path] || path.split('/').pop() || '';

    function initOriginalSongs() {
      originalSongs = shuffle(Object.entries(SONGS));
    }

    function getNextAd() {
      if (shuffledAds.length === 0) shuffledAds = shuffle(ADS.slice());
      const index = adIndex++;
      return {
        src: shuffledAds[index % shuffledAds.length],
        endType: index % 2 === 0 ? 'even' : 'odd'
      };
    }

    function getNextJingle() {
      if (shuffledJingles.length === 0) shuffledJingles = shuffle(JINGLES.slice());
      return shuffledJingles[jingleIndex++ % shuffledJingles.length];
    }

    async function addTracksToQueue(count) {
      if (originalSongs.length === 0) initOriginalSongs();

      for (let i = 0; i < count; i++) {
        if (originalSongs.length === 0) initOriginalSongs();

        let found = false;
        let title, data;

        while (originalSongs.length > 0 && !found) {
          [title, data] = originalSongs.shift();
          if (!queue.slice(playIndex).some(item => item.title === title && item.type === 'song')) {
            found = true;
          }
        }

        if (!found) continue;

        // –õ–µ–Ω–∏–≤–æ –ø–æ–¥–≥—Ä—É–∂–∞–µ–º –∞—É–¥–∏–æ –ø–µ—Å–Ω—é –∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏
        const songSrc = await getBlobUrl(`songs/${data.link}`);

        let comments = [];
        const commentKeys = Object.keys(data.comments || {});
        if (commentKeys.length === 0 && RANDOM.length > 0) {
          //const randomIndex = Math.floor(Math.random() * RANDOM.length);
          //const randomCommentSrc = await getBlobUrl(`random/${RANDOM[randomIndex]}`);
          //comments = [{ name: '—Å–ª—É—á–∞–π–Ω—ã–π', src: randomCommentSrc, fileName: extractFileName(randomCommentSrc) }];
          //console.log('–ü—É—Å—Ç–æ')
        } else {
          comments = await Promise.all(
            commentKeys.map(async (k) => {
              const src = await getBlobUrl(`songs/${data.comments[k]}`);
              return { name: k, src, fileName: extractFileName(src) };
            })
          );
        }

        queue.push({
          type: 'song',
          title,
          songSrc,
          fileName: extractFileName(songSrc),
          comments
        });

        songsSinceLastJingle++;
        if (songsSinceLastJingle >= 1 && JINGLES.length) {
          const jinglePath = `j/${getNextJingle()}`;
          const jingleSrc = await getBlobUrl(jinglePath);
          queue.push({ type: 'jingle', title: 'üéµ –î–∂–∏–Ω–≥–ª', songSrc: jingleSrc, fileName: extractFileName(jingleSrc) });
          songsSinceLastJingle = 0;
        }

        const songsCount = queue.filter(item => item.type === 'song').length;
        if (songsCount > 0 && songsCount % 4 === 0 && ADS.length) {
          const adObj = getNextAd();
          const adSrc = await getBlobUrl(`ads/${adObj.src}`);
          queue.push({
            type: 'ad',
            title: 'üì¢ –†–µ–∫–ª–∞–º–∞',
            songSrc: adSrc,
            fileName: extractFileName(adSrc),
            adEndType: adObj.endType
          });
        }
      }
    }


    const updateDisplay = () => {
      const nowDiv = document.getElementById('now-playing');
      const queueDiv = document.getElementById('queue');
      const current = queue[playIndex] || {};
      nowDiv.innerHTML = `<div class="playing">üéß –°–µ–π—á–∞—Å: ${current?.title || '---'} (${current?.fileName || ''})</div>`;
      queueDiv.innerHTML = queue.slice(playIndex + 1, playIndex + 10).map((item, i) => {
        let icon = '';
        if (item.type === 'ad') icon = 'üì¢';
        else if (item.type === 'jingle') icon = 'üéµ';
        else if (item.type === 'hour-signal') icon = 'üïí';
        return `<div class="track">${i + 1}) ${item.title} ${icon} (${item.fileName || ''})</div>`;
      }).join('');
    };

    let hourSignalPending = false;

    const checkAndQueueHourSound = () => {
      const hour = new Date().getHours();
      if (hour !== currentHour && hourSounds[hour]) {
        currentHour = hour;
        hourSignalPending = true;
      }
    };

    const playAudio = (src) => {
      return new Promise(resolve => {
        miscAudio.pause();
        miscAudio.src = src;
        miscAudio.volume = 1;
        miscAudio.onended = resolve;
        miscAudio.play();
      });
    };

    async function playNext() {
      if (queue.length - playIndex < QUEUE_AHEAD) {
        await addTracksToQueue(QUEUE_AHEAD - (queue.length - playIndex));
      }

      updateDisplay();
      if (playIndex >= queue.length) return;

      if (hourSignalPending) {
        const hourSrc = await getBlobUrl(`h/${currentHour}.mp3`);
        queue.splice(playIndex, 0, {
          type: 'hour-signal',
          title: `üïí –°–∏–≥–Ω–∞–ª ${currentHour}:00`,
          songSrc: hourSrc,
          fileName: `h (${currentHour}).mp3`
        });
        hourSignalPending = false;
      }

      const item = queue[playIndex];
      playIndex++;

      if (item.type === 'song') {
        const songData = SONGS[item.title];
        const together = songData.together === 1;
        const hasComment = item.comments.length > 0;

        if (together) {
          musicAudio.src = item.songSrc;
          musicAudio.play();
          if (hasComment) {
            voiceAudio.src = item.comments[Math.floor(Math.random() * item.comments.length)].src;
            await delay(500);
            for (let v = 1; v >= 0.1; v -= 0.05) {
              musicAudio.volume = v;
              await delay(30);
            }
            voiceAudio.play();
            await new Promise(resolve => voiceAudio.onended = resolve);
            for (let v = 0.1; v <= 1; v += 0.05) {
              musicAudio.volume = v;
              await delay(30);
            }
          }
          await new Promise(resolve => musicAudio.onended = resolve);
        } else {
          if (hasComment) {
            voiceAudio.src = item.comments[Math.floor(Math.random() * item.comments.length)].src;
            voiceAudio.play();
            await new Promise(resolve => voiceAudio.onended = resolve);
          }
          musicAudio.src = item.songSrc;
          musicAudio.play();
          await new Promise(resolve => musicAudio.onended = resolve);
        }
      } else if (item.type === 'ad') {
        voiceAudio.src = DTMF.adStart ? await getBlobUrl(DTMF.adStart) : null;
        if (voiceAudio.src) await playAudio(voiceAudio.src);
        await playAudio(item.songSrc);

        if (item.adEndType === 'even') {
          const evenEndingKey = adEvenIndex % 2 === 0 ? 'adEndEven1' : 'adEndEven2';
          adEvenIndex++;
          await playAudio(await getBlobUrl(DTMF[evenEndingKey]));
        } else {
          await playAudio(await getBlobUrl(DTMF.adEndOdd));
        }
      } else if (item.type === 'jingle') {
        await playAudio(item.songSrc);
      } else if (item.type === 'hour-signal') {
        await playAudio(item.songSrc);
        await playAudio(await getBlobUrl(DTMF.newHour));
      }

      checkAndQueueHourSound();
      await playNext();
    }


    document.getElementById('zipInput').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;

      document.getElementById('status').textContent = "üì¶ –†–∞—Å–ø–∞–∫–æ–≤–∫–∞ ZIP...";
      const zip = await JSZip.loadAsync(file);

      window.loadedZip = zip;

      const contentRaw = await zip.file("content.js").async("string");
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∞ —Å pathToOriginalFileName –≤ content.js
      // –ï—Å–ª–∏ content.js —Ç–∞–∫–∂–µ –æ–±—ä—è–≤–ª—è–µ—Ç pathToOriginalFileName, –Ω—É–∂–Ω–æ —É–±—Ä–∞—Ç—å const/let —Ç–∞–º –∏–ª–∏ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å
      const wrapperFn = new Function("global", contentRaw);
      wrapperFn(window);

      SONGS = window.SONGS;
      JINGLES = window.JINGLES || [];
      ADS = window.ADS || [];
      DTMF = window.DTMF || {};
      RANDOM = window.RANDOM || [];

      // –ó–∞–≥—Ä—É–∂–∞–µ–º —á–∞—Å–æ–≤—ã–µ –∑–≤—É–∫–∏ –≤ hourSounds (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ)
      for (let h = 0; h < 24; h++) {
        const key = `h/${h}.mp3`;
        if (window.loadedZip.file(key)) {
          hourSounds[h] = await getBlobUrl(key);
        }
      }

      document.getElementById('status').textContent = "‚úÖ ZIP –∑–∞–≥—Ä—É–∂–µ–Ω. –ó–∞–ø—É—Å–∫ —ç—Ñ–∏—Ä–∞...";
      initOriginalSongs();
      await addTracksToQueue(QUEUE_AHEAD);

      // –°–¥–µ–ª–∞–ª –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ async, —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ await playNext()
      document.getElementById('skipButton').addEventListener('click', async () => {
        musicAudio.pause();
        musicAudio.currentTime = 0;
        voiceAudio.pause();
        voiceAudio.currentTime = 0;
        miscAudio.pause();
        miscAudio.currentTime = 0;

        await playNext();
      });

      setInterval(checkAndQueueHourSound, 10 * 1000);
      await playNext();
    });
  </script>
</body>

</html>